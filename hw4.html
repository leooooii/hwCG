<!DOCTYPE html>

<html>

<head>
<style>
#info {
  position: absolute;
  top: 0px;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffffff
}

body {
  overflow: hidden;
}



</style>
</head>

<div id="info">hw4-1 
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js">
</script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
	<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>




	
<script>
 
  
 
 class Ball {
	constructor (mesh, rad = 2, color) {
    this.mesh = mesh;
    this.mesh.position.y=3
    this.radius = rad;
    this.mesh.material.color =color ;
   // scene.add (this.light)
  //  scene.add (this.mesh)   // add to scene when particle is created
	this.mesh.material.color.copy ( color.clone() );
  }
  
  update (angle) { 
 
  /* var k = 5;
  var x = -120 * Math.cos(k * angle) * Math.sin(angle) -120* k * Math.sin(k * angle) * Math.cos(angle);
  var y = 120 * Math.cos(k*angle)*Math.cos(angle)-120*k*Math.sin(k*angle)*Math.sin(angle);  
  this.mesh.position.set(Math.cos(angle)*Math.cos(k*angle)*120,120*Math.cos(k * angle)* Math.sin(angle),3)*/
  //this.mesh.rotation.x = -Math.PI / 2
  this.mesh.position.z=2
  //this.mesh.rotation.z = Math.atan2(y,x);
  }


}


class obstacle {
  constructor(mesh, width, height) {
    this.mesh = mesh;
    this.width = width;
    this.height = height;
    mesh.position.z = 1;
    this.max = new THREE.Vector3(mesh.position.x + width / 2, 0, mesh.position.z + height / 2);
    this.min = new THREE.Vector3(mesh.position.x - width / 2, 0, mesh.position.z - height / 2);
   // console.log(this.max)
    scene.add(this.mesh);
  }
  update() {
  this.mesh.updateMatrixWorld() 
     this.max = new THREE.Vector3(this.mesh.position.x + this.width / 2, this.mesh.position.z + this.height / 2);
    this.min = new THREE.Vector3(this.mesh.position.x - this.width / 2,this.mesh.position.z - this.height / 2);
    //console.log(this.min)
    this.collidingCircle(ball);
  }
  collidingCircle(ball) {
  
    var a = this.max.clone().sub(ball.mesh.position.clone());
    // console.log(a)
   console.log(ball.mesh.position)
    var b = this.min.clone().sub(ball.mesh.position.clone());
    
    if (a.x < 0) 
    {
      if (a.y < 0){ return (a.x * a.x + a.y * a.y <r * r);}
      else if (b.y > 0) return (a.x * a.x + b.y * b.y < r * r);
      else {return Math.abs(a.x) <r;}
    } 
    else if (b.x > 0) 
    {  
      if (a.y < 0) return (b.x * b.x + a.z * a.y < r * r);
      else if (b.y > 0) return (b.x * b.x + b.y * b.y< r * r);
      else
      { return b.x < r;}
    } 
    else 
    {
      if (a.y < 0) return Math.abs(a.y) <r;
      else if (b.y > 0) return b.y < r
      else return true;
    }
  }
}


///////////////////////////////////////////////////////////////////////
var camera, scene, renderer, light;
var keyboard = new KeyboardState();
var ball,rectangle,angle=0;
var boxs =[]
var balls = []
var clock,r;
var mouse = new THREE.Vector2();
var raycaster;
var pickables=[];

init();
animate();


  
function init() 
{
  scene = new THREE.Scene();
  clock = new THREE.Clock();
  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  //camera.position.y = 200;
	camera.position.z = 300;

  light = new THREE.PointLight(0xffffff);
  light.position.set(100, 500,500);
  //scene.add(light);

  var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
  scene.add(gridXZ);
  gridXZ.rotation.x=Math.PI/2
  
  var floor = new THREE.Mesh (new THREE.PlaneGeometry (300,300), new THREE.MeshBasicMaterial({  transparent: true,
    opacity: 0.5}))
  //floor.rotation.x = -Math.PI/2
  scene.add (floor)
  pickables = [floor];
 
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  
  controls.enableKeys = false;
  
  document.body.appendChild(renderer.domElement);
  ///////////////////////////////////////////////////////////
  
  let disk;
  r=10;
  disk = new THREE.Mesh (new THREE.CircleGeometry (r, r,32), new THREE.MeshBasicMaterial() )

	ball = new Ball (disk, 10, new THREE.Color (0x00ffff))
  
   raycaster = new THREE.Raycaster();
  document.addEventListener('mousedown', onDocumentMouseDown, false);
  
  
  let box;
  box=new THREE.Mesh(new THREE.PlaneGeometry(80,80),new THREE.MeshBasicMaterial({color:0xffff00,opacity:0.6,transparent:true}))
  rectangle=new obstacle(box,80,80);
  rectangle.update();
  boxs.push(rectangle);
  
 /*box=new THREE.Mesh(new THREE.BoxGeometry(20,30,20),new THREE.MeshPhongMaterial({color:0xffff00,opacity:0.6,transparent:true}))
  rectangle=new obstacle(box,20,20);
  rectangle.update();
 box.position.set(50,15,50);
  boxs.push(rectangle);*/
  
}
function onDocumentMouseDown(event) {

  event.preventDefault();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  // find intersections
  raycaster.setFromCamera(mouse, camera);
  var intersects = raycaster.intersectObjects(pickables);
  if (intersects.length > 0) {
   scene.add(ball.mesh)
  ball.mesh.position.copy(intersects[0].point);
   console.log(intersects[0].point)
  }

}

function animate() {
    var dt = clock.getDelta();
    angle+=0.003
	//balls.forEach (function(b) {b.update(dt)})
 ball.update (angle)
 for (let i = 0; i < boxs.length; i++) {boxs[i].update();}
 // console.log(rectangle.collidingCircle(balls))
 for (let i = 0; i < boxs.length; i++) 
 {
  if(boxs[i].collidingCircle(ball)==true) {ball.mesh.material.color = new THREE.Color(0xffd0ff);}
  else ball.mesh.material.color = new THREE.Color(0x00ffff)
  }
  requestAnimationFrame(animate);
  render();
}

function render() {
  renderer.render(scene, camera);
}







</script>
</body>

</html>